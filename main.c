#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  WELCOME,
  LOAD,
  START,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  struct player p;
  struct enemy e[ENEMYCOUNT];
  struct coin c[COINCOUNT];
  int directions[] = {-2, -1, 1, 2};
  int nDirections = sizeof(directions) / sizeof(directions[0]);

  // Save current and previous state of button input.
  //u32 previousButtons = BUTTONS;
  //u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = WELCOME;

  while (1) {
    //currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case WELCOME:
        //setup welcome page
        waitForVBlank();
        drawFullScreenImageDMA(titlescreen);  //load title screen
        state = LOAD; //go to gameplay setup
        break;
      case LOAD:  ;
        //Set up text on screen
        char buffer1[50];
        char buffer2[50];
        char buffer5[50];
        sprintf(buffer2, "Press ENTER to play");
        sprintf(buffer1, "Objective: Secure all 5 pilots(yellow)!");
        sprintf(buffer5, "Avoid enemy ships(blue)!");
        //Show text on screen
        waitForVBlank();
        drawString(129, 2, buffer1, RED);
        drawString(139, 50, buffer5, RED);
        drawString(149, 60, buffer2, RED);
        //Press enter to start game(go to game setup)
        if (KEY_DOWN(BUTTON_START, BUTTONS)) {
            state = START;
        }
        break;
      case START:
        //setup player
        p.size = PLAYERSIZE;
        p.row = HEIGHT/2 - p.size/2;
        p.col = WIDTH/2 - p.size/2; 
        p.color = PLAYERCOLOR;
        p.speed = PLAYERSPEED;
        //p.count = PLAYERCOUNT;

        //setup enemies
        for (int i = 0; i < ENEMYCOUNT; i++) {
          //Randomize enemy spawn positions
          e[i].row = rand() % HEIGHT;
          e[i].col = rand() % WIDTH;
          //Rrandomize enemy directions
          e[i].rowDirection = directions[rand() % nDirections];
          //e[i].colDirection = directions[rand() % nDirections];
        }
        //setup pilots
        for (int i = 0; i < COINCOUNT; i++) {
          //Randomize pilots spawn positions
          c[i].row = rand() % HEIGHT;
          c[i].col = rand() % WIDTH;
          //Randomize pilots directions
          c[i].rowDirection = directions[rand() % nDirections];
          c[i].colDirection = directions[rand() % nDirections];
          //Set all pilots to be alive
          c[i].alive = 1;
        }
        //Start game
        state = PLAY;
        break;
      case PLAY:
        waitForVBlank();
        //backSpace to reset
        if (KEY_DOWN(BUTTON_SELECT, BUTTONS)) {
            state = WELCOME;
        }
        //draw background
        drawRectDMA(0, 0, 240, 160, BLACK);
        //draw player
        
        //directional control
        if (KEY_DOWN(BUTTON_UP, BUTTONS)) {
          p.row = p.row - p.speed;
          //Set screen edge boundary
          if (p.row < 0) {
            p.row = 0;
          }
        }
        if (KEY_DOWN(BUTTON_DOWN, BUTTONS)) {
          p.row = p.row + p.speed;
          //Set screen edge boundary
          if (p.row > HEIGHT - p.size) {
            p.row = HEIGHT - p.size;
          }
        }
        if (KEY_DOWN(BUTTON_LEFT, BUTTONS)) {
          p.col = p.col - p.speed;
          //Set screen edge boundary
          if (p.col < 0) {
            p.col = 0;
          }
        }
        if (KEY_DOWN(BUTTON_RIGHT, BUTTONS)) {
          p.col = p.col + p.speed;
          //Set screen edge boundary
          if (p.col > WIDTH - p.size) {
            p.col = WIDTH - p.size;
          }
        }
        //draw player
        drawRectDMA(p.row, p.col, p.size, p.size, p.color);
        
        //enemy movement
        for (int i = 0; i < ENEMYCOUNT; i++) {
          //Set enemy travel speed and direction
          e[i].row = e[i].row + e[i].rowDirection;
          e[i].col = e[i].col + e[i].colDirection;
          //Set screen edge boundaries
          if (e[i].row < 0) {
            e[i].row = 0;
            e[i].rowDirection = -e[i].rowDirection;
          }
          if (e[i].row > HEIGHT - ENEMYSIZE) {
            e[i].row = HEIGHT - ENEMYSIZE;
            e[i].rowDirection = -e[i].rowDirection;
          }
          if (e[i].col < 0) {
            e[i].col = 0;
            e[i].colDirection = -e[i].colDirection;
          }
          if (e[i].col > WIDTH - ENEMYSIZE) {
            e[i].col = WIDTH - ENEMYSIZE;
            e[i].colDirection = -e[i].colDirection;
          }
          //end game if player collide with enemy
          if (collision(p.col, p.col + p.size, p.row, p.row + p.size, e[i].col, e[i].col + ENEMYSIZE, e[i].row, e[i].row + ENEMYSIZE)) {
              state = LOSE;
          }
          //draw enemy at pixel location
          drawImageDMA(e[i].row, e[i].col, ENEMYSIZE, ENEMYSIZE, alien);
        }
        
        //pilot movement
        for (int i = 0; i < COINCOUNT; i++) {
          //Set enemy travel speed and direction
          c[i].row = c[i].row + c[i].rowDirection;
          c[i].col = c[i].col + c[i].colDirection;
          //Set screen edge boundaries
          if (c[i].row < 0) {
            c[i].row = 0;
            c[i].rowDirection = -c[i].rowDirection;
          }
          if (c[i].row > HEIGHT - COINSIZE) {
            c[i].row = HEIGHT - COINSIZE;
            c[i].rowDirection = -c[i].rowDirection;
          }
          if (c[i].col < 0) {
            c[i].col = 0;
            c[i].colDirection = -c[i].colDirection;
          }
          if (c[i].col > WIDTH - COINSIZE) {
            c[i].col = WIDTH - COINSIZE;
            c[i].colDirection = -c[i].colDirection;
          }
          //Check player pilot collision
          if (collision(p.col, p.col + p.size, p.row, p.row + p.size, c[i].col, c[i].col + COINSIZE, c[i].row, c[i].row + COINSIZE)) {
            c[i].alive = 0;
            for (int j = 0; j < COINCOUNT; j++) {
              //Game continues if there are pilots still alive
              if (c[j].alive) {
                break;
              }
              //Win if all pilots resucued
              if (j == COINCOUNT - 1) {
                state = WIN;
              }
            }
          }
          //Draw pilot if there are still left
          //Draw number of pilots left to rescue
          int count = 0;
          if (c[i].alive) {
            for (int j = 0; j < COINCOUNT; j++) {
              if (c[j].alive) {
                count++;
              }
            }
              char text[12];
              sprintf(text, "%d", count);
              drawString(10, 220, text, WHITE);
              drawImageDMA(c[i].row, c[i].col, COINSIZE, COINSIZE, rescue);
          }
        }
        break;
      case WIN:
        waitForVBlank();
        //backSpace to reset
        if (KEY_DOWN(BUTTON_SELECT, BUTTONS)) {
          state = WELCOME;
        }
        //draw winscreen
        drawFullScreenImageDMA(winscreen);
        char buffer3[50];
        sprintf(buffer3, "Press ENTER to play again!");
        drawString(149, 45, buffer3, RED);
        //Play again
        if (KEY_DOWN(BUTTON_START, BUTTONS)) {
          state = START;
        }
        break;
      case LOSE:
        waitForVBlank();
        //backSpace to reset
        if (KEY_DOWN(BUTTON_SELECT, BUTTONS)) {
          state = WELCOME;
        }
        //draw winscreen
        drawFullScreenImageDMA(losescreen);
        char buffer4[50];
        sprintf(buffer4, "Press ENTER to play again.");
        drawString(149, 45, buffer4, RED);
        //Play again
        if (KEY_DOWN(BUTTON_START, BUTTONS)) {
            state = START;
        }
        break;
    }
    //previousButtons = currentButtons; // Store the current state of the buttons
  }
  //UNUSED(previousButtons); // You can remove this once previousButtons is used
  return 0;
}

//Check for collision
int collision(int aLeft, int aRight, int aTop, int aBottom, int bLeft, int bRight, int bTop, int bBottom) {
  if ((aLeft > bRight) || (aRight < bLeft) || (aTop > bBottom) || (aBottom < bTop)) {
    return 0; //False
  }
  return 1; //True
}
